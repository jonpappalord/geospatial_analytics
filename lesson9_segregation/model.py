import numpy as np
import random

from mesa import Model, Agent
from mesa.time import RandomActivation
from mesa.space import SingleGrid
from mesa.datacollection import DataCollector

import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
import matplotlib.colors as colors

class SchellingModel(Model):
    '''
    Model class for the Schelling segregation model.
    '''
    def __init__(self, side =10, density=0.7, minority_pc=0.3, homophily =0.3):
        '''
        side: side of the grid square
        density: density of population
        minority_pc: percentage of minority type (2 types in ths case)
        homophily: percentage of neighbours requested of same type
        '''

        self.side = side
        self.density = density
        self.minority_pc = minority_pc
        self.homophily = homophily

        #A scheduler which activates each agent once per step, in random order, with the order reshuffled every step
        self.schedule = RandomActivation(self)

        #Grid where each cell contains exactly at most one object. default rectangular
        self.grid = SingleGrid(width=side, height=side, torus=False)

        #Reset total happy agents counting
        self.total_happy = 0

        #Standard way to collect data generated by a Mesa model. 
        #It collects three types of data: model-level data, agent-level data, and tables

        self.datacollector = DataCollector(
            {"perc_happy": lambda m: m.total_happy/m.schedule.get_agent_count(),
             "tot_seg": lambda m: np.mean([a.segregation for a in self.schedule.agents])},
            {"x": lambda a: a.pos[0], 
             "y": lambda a: a.pos[1],
             "segregation": lambda a: a.segregation})

        #Boolean attributes indicating if the model should continue running
        self.running = True

        agent_id=0

        # Set up agents
        # We use a grid iterator that returns
        # the coordinates of a cell as well as
        # its contents. (coord_iter)
        for cell in self.grid.coord_iter():
            x = cell[1]
            y = cell[2]

            if random.random() < self.density:              #if true, selected cell is populated, else is empty
                if random.random() < self.minority_pc:      #if true, cell is populated with minority, else with majority type
                    agent_type = 1
                else:
                    agent_type = 2

                agent = SchellingAgent(agent_id, (x, y), self, agent_type)      #instance of agent class
                agent_id += 1
                self.grid.place_agent(agent, (x, y))    #Positions an agent on the grid, and set its pos variable.                        
                self.schedule.add(agent)                   #Add an Agent object to the schedule.



    def step(self):
        '''
        Run one step of the model. If All agents are happy, halt the model.
        '''
        self.total_happy = 0                                        #Reset counter of happy agents
        self.schedule.step()                                        #Call agents steps
        self.datacollector.collect(self)                            #Collect all the data for the given model object    
        if self.total_happy == self.schedule.get_agent_count():     #Halt condition
            self.running = False


    def show(self):
        agent_counts = np.zeros((self.grid.width, self.grid.height))
        for cell in self.grid.coord_iter():
            cell_content, x, y = cell
            if cell_content != None: 
                agent_counts[x][y] = cell_content.type

        cmap = colors.ListedColormap(['white', '#ff3300','#0033ff'])
        plt.imshow(agent_counts, interpolation="nearest", cmap=cmap)
        ax = plt.gca()
        major_ticks = np.arange(-0.5,self.side-0.5,1)
        ax.set_xticks(major_ticks)
        ax.set_yticks(major_ticks)
        ax.grid(True)
        ax.set_xticklabels([])
        ax.set_yticklabels([])
        plt.show()


class SchellingAgent(Agent):
    '''
    Schelling segregation agent
    '''
    def __init__(self, unique_id, pos, model, agent_type):
        '''
        unique_id: id identifying agents
        pos: tuple of (x,y) coordinates
        model: model of agent
        agent_type: could be 1 or 2
        '''
        super().__init__(unique_id, model) 
        self.pos = pos
        self.type = agent_type
        self.tot_neighbors=8

    def step(self):
        similar = 0                                                         #Reset similar counting
        neighbors = self.model.grid.iter_neighbors(self.pos, "moore")       #Return an iterator over neighbors to a certain point
        for neighbor in neighbors:
            if neighbor.type == self.type:
                similar += 1

        self.segregation = similar/self.tot_neighbors

        if self.segregation < self.model.homophily:
            self.model.grid.move_to_empty(self)
        else:
            self.model.total_happy += 1
